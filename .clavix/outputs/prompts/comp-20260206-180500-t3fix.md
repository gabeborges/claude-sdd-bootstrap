---
id: comp-20260206-180500-t3fix
depthUsed: comprehensive
timestamp: 2026-02-06T18:05:00Z
updated: 2026-02-06T19:15:00Z
executed: true
originalPrompt: "I've tested this bootstrap project in a real project. So far I just finished the planning phase. I'm pasting the results in .samples/build so you can take a look. Use agent sdd-specialist to analyze these files. These files: compliance-requirements.md, component-architecture.md, security-patterns.md, task-order.md, ux-flow.md, I'd like to know why they were created? Are they going to be used in development phase by any agent? Does agents really need them to complete the task? If they are for agents, isn't there a better format file? compliance-requirement.md should it be part of specs as it is a requirement? Should it live in the build level as compliance requirements don't change? component-architecture could it be a yaml file? Should it be at the build level as these components will be reused by many builds? security-patterns it has requirements and checklist, wouldn't be better to have requirements inside specs and a checklist in a yaml format for AI tracking? task-order.md is that for AI? If so, why not yaml? ux-flow, shouldn't it be on build level? Reflect on these questions but also think about how to make this better. It feels like agents are spawning files and they don't seem to really connect to the SDD flow or being used by agents."
---

# Improved Prompt

## SDD Planning Phase: Fix Artifact Drift + Two Structural Gaps

### Context
This is a **bootstrap project** (claude-sdd-bootstrap). The source lives in `claude/agents/` and gets installed as `.claude/agents/` in real projects. Agent definition files DO exist and already have correct output contracts. The problem is that shared reference docs contradict or omit what the agent definitions specify, AND two deeper structural issues exist in the SDD flow itself.

### Problem 1: Tier 3 Artifact Drift (unchanged from prior analysis)

Tier 3 agents (ui-designer, security-engineer, compliance-engineer) produced orphaned files during a real-project planning phase test. These files don't match what the agent definitions specify:

| Orphaned File Produced | Agent Definition Says Write To | Mismatch |
|---|---|---|
| `ux-flows.md` (build-version level) | `<feature>/ui.md` (per-feature) | Wrong name, wrong scope |
| `component-architecture.md` (build-version level) | Updates `<feature>/ui.md` (per-feature) | Wrong name, wrong scope, wrong agent (frontend-designer, not ui-designer) |
| `security-patterns.md` (build-version level) | `<feature>/security.md` (per-feature) | Wrong name, wrong scope |
| `compliance-requirements.md` (build-version level) | `<feature>/compliance.md` (per-feature) | Wrong name, wrong scope |

**Root Cause**: `instructions.md` Agent I/O table uses vague descriptions instead of canonical file paths, and folder structures in both `instructions.md` and `AGENTS.md` omit Tier 3 outputs entirely. Agents improvise when the shared docs don't match their definitions.

### Problem 2: `db-migration-plan.yaml` Is Defined Per-Feature But Should Be Build-Level

**The contradiction:** All 12+ definition files (AGENTS.md, CLAUDE.md, database-administrator.md, instructions.md, project-task-planner.md, fullstack-developer.md, swarm-config.md, sdd-protocols SKILL, db-migration SKILL, db/plan command, orchestrate command, README.md) unanimously say per-feature path: `.ops/build/v{x}/<feature-name>/db-migration-plan.yaml`

**But the real-world sample** at `.samples/build/v0/db-migration-plan.yaml` is a single build-level consolidated plan (44KB, 8 tables across 7 features, FK-ordered). Zero per-feature db-migration-plan.yaml files exist in any of the 7 sample feature directories.

**Why build-level is architecturally correct:**
- **FK dependency ordering requires cross-feature visibility.** Feature A's `bookings` table has FK to Feature B's `services` table — per-feature plans can't express this ordering.
- **`system-design.yaml` (the input) is already build-level.** It contains `data.entities` and `data.key_constraints` spanning the entire product. The output should match the input scope.
- **RLS policies span tables across features.** The sample's Phase 9 applies RLS to ALL 8 tables — some policies reference tables owned by other features.
- **Rollback must be globally ordered.** Dropping `therapists` (feature A) is unsafe until `services` (feature B) and `bookings` (feature C) are dropped first. Only a build-level plan has this view.
- **Per-feature creates deployment ordering problems.** The fullstack-developer or deployment pipeline would have to figure out which feature's migration runs first — that's the db-migration-plan's job.

**Required fix:** Change path in all 12+ definition files from `.ops/build/v{x}/<feature-name>/db-migration-plan.yaml` to `.ops/build/v{x}/db-migration-plan.yaml`. The database-administrator reads ALL features' `specs.md` + the build-level `system-design.yaml` and produces a single consolidated migration plan.

### Problem 3: Cross-Feature Orchestration Is Undocumented — `task-order.md` Fills a Real Gap

**Previous analysis said** `task-order.md` should be deleted because it duplicates `tasks.yaml` `depends_on` fields. **This was wrong.**

**The real situation:**
- The workflow-orchestrator is explicitly scoped to **one feature at a time** (`/orchestrate <feature-path>`). It has no protocol for choosing which feature to build first.
- The tier DAG (T1→T6) defines **agent order within a feature**, not feature order.
- No agent, command, skill, or protocol document defines how to sequence features when a build has multiple features.
- Individual `tasks.yaml` files **already contain cross-feature `depends_on` references** (e.g., `T-BM-002` in booking-management depends on `T-BP-007` from booking-page), but no agent consolidates, validates, or plans around them.
- `task-order.md` is the **only artifact** that addresses this gap — it organizes 7 features' tasks into 14 cross-feature layers with explicit dependency chains.

**The gap is real. The file format and ownership are wrong.**

`task-order.md` shouldn't be a free-form markdown file improvised by the project-task-planner. It should be:
- A **canonical SDD artifact** with a defined producer, consumer, path, and format
- **YAML format** (`build-order.yaml`) so the orchestrator can parse it programmatically
- **Build-version level** (sits next to `db-migration-plan.yaml` and `prd.md`)
- **Produced by the project-task-planner** (who already reads all features' specs and tasks) or by a dedicated step in the orchestrator
- **Consumed by the workflow-orchestrator** to determine feature execution sequence

### Required Changes

#### 1. Fix `instructions.md` Agent I/O Table
Replace vague output descriptions with canonical file paths:

| Agent | Outputs — CURRENT (vague) | Outputs — FIXED (canonical) |
|---|---|---|
| ui-designer | "UX flows, screens, states, accessibility notes" | `.ops/build/v{x}/<feature>/ui.md`; updates `specs.md` with UX acceptance checks |
| frontend-designer | "Component breakdown (components/props/states)" | Updates `.ops/build/v{x}/<feature>/ui.md` with component breakdown |
| security-engineer | "Security patterns/decisions; updates specs.md" | `.ops/build/v{x}/<feature>/security.md`; updates `specs.md` with security checks |
| compliance-engineer | "Compliance requirements; updates specs.md" | `.ops/build/v{x}/<feature>/compliance.md`; updates `specs.md` with compliance checks |
| database-administrator | `db-migration-plan.yaml` (per-feature path) | `.ops/build/v{x}/db-migration-plan.yaml` (build-level, consolidated) |

#### 2. Fix `db-migration-plan.yaml` Path in All 12+ Files
Change from `.ops/build/v{x}/<feature-name>/db-migration-plan.yaml` to `.ops/build/v{x}/db-migration-plan.yaml` in:
- `AGENTS.md` (folder structure + artifact table)
- `CLAUDE.md` (artifact flow)
- `claude/agents/database-administrator.md` (Writes section)
- `claude/agents/instructions.md` (I/O table + folder structure)
- `claude/agents/project-task-planner.md` (Reads section)
- `claude/agents/fullstack-developer.md` (Reads section)
- `claude/agents/swarm-config.md` (output path)
- `claude/skills/sdd-protocols/SKILL.md`
- `claude/skills/db-migration/SKILL.md`
- `claude/commands/db/plan.md`
- `claude/commands/orchestrate.md`
- `README.md`

Update `database-administrator.md` process to read ALL features' `specs.md` in the build version, not just one.

#### 3. Introduce `build-order.yaml` as a Canonical Artifact
- **Path**: `.ops/build/v{x}/build-order.yaml`
- **Producer**: project-task-planner (after generating all features' `tasks.yaml`)
- **Consumer**: workflow-orchestrator (to determine feature execution sequence)
- **Format**: YAML with cross-feature layers, dependency chains, parallelization groups
- **Prerequisite**: All features' `tasks.yaml` must exist
- Add to SDD Artifact Flow: `specs.md` → `system-design.yaml` → `db-migration-plan.yaml` → `tasks.yaml` (per feature) → **`build-order.yaml`** (cross-feature)

#### 4. Fix Folder Structure in Both `instructions.md` and `AGENTS.md`

```yaml
.ops/build/v{x}/
  ├── prd.md                        # user/Clavix (build-level)
  ├── implementation-status.md      # context-manager (build-level)
  ├── db-migration-plan.yaml        # database-administrator (build-level, consolidated)
  ├── build-order.yaml              # project-task-planner (build-level, cross-feature)
  └── <feature-name>/
      ├── specs.md                  # spec-writer
      ├── tasks.yaml                # project-task-planner
      ├── ui.md                     # ui-designer (conditional — features with UI)
      ├── security.md               # security-engineer (conditional — security-sensitive)
      ├── compliance.md             # compliance-engineer (conditional — compliance-sensitive)
      ├── checks.yaml               # gate results (all agents write sections)
      └── spec-change-requests.yaml # any agent (escalation)
```

Note: `system-design.yaml` remains at `.ops/build/system-design.yaml` (product-level, spanning versions).

#### 5. Eliminate Orphaned Files from Sample Output
- `ux-flows.md` → Should have been per-feature `ui.md` files
- `component-architecture.md` → Should not exist; `frontend-designer` updates per-feature `ui.md`
- `security-patterns.md` → Should have been per-feature `security.md` files
- `compliance-requirements.md` → Should have been per-feature `compliance.md` files
- `task-order.md` → Replace with canonical `build-order.yaml` (YAML, build-level, with defined producer/consumer)

#### 6. Add Tier 3 Outputs + Build-Level Artifacts to Gate Checks
Update `gate/check.md` and `gate/report.md` to validate:
- `security.md` exists for security-sensitive features
- `compliance.md` exists for compliance-sensitive features
- `ui.md` exists for features with UI
- `db-migration-plan.yaml` exists at build-version level (not per-feature)
- `build-order.yaml` exists when build has multiple features
- Only canonical filenames present in feature workspace (reject orphaned files)

#### 7. Clarify Baseline vs Per-Feature Split
Content that doesn't change per feature should NOT be regenerated per feature:
- Cross-cutting compliance rules → `.ops/security-compliance-baseline.md` (already exists)
- Cross-cutting security patterns → `.ops/security-compliance-baseline.md` (already exists)
- Reusable UI components → `.ops/ui-design-system.md` (already exists)

Per-feature files (`security.md`, `compliance.md`, `ui.md`) contain ONLY the feature-specific delta.

#### 8. Update Workflow Orchestrator for Multi-Feature Builds
Add protocol for multi-feature orchestration:
- Before running `/orchestrate <feature>`, check if `build-order.yaml` exists
- If it exists, follow the layer sequence to determine which feature to orchestrate next
- If it doesn't exist, and multiple features are in scope, STOP and request `build-order.yaml` generation

### Validation
After changes, re-run the planning phase for a multi-feature build and verify:
- No files created outside the canonical folder structure
- Every file uses the canonical name from its agent definition
- `db-migration-plan.yaml` is at build-version level, not per-feature
- `build-order.yaml` is generated with cross-feature ordering
- No orphaned files (task-order.md, ux-flows.md, etc.)
- Gate checks validate the new artifacts
- Orchestrator can consume `build-order.yaml` to sequence features

## Quality Scores
- **Clarity**: 85%
- **Efficiency**: 70%
- **Structure**: 65%
- **Completeness**: 90%
- **Actionability**: 75%
- **Specificity**: 85%
- **Overall**: 78% (good)

## Original Prompt
```
I've tested this bootstrap project in a real project. So far I just finished the "planning phase". I'm pasting the results in .samples/build so you can take a look. These files: compliance-requirements.md, component-architecture.md, security-patterns.md, task-order.md, ux-flow.md — why were they created? Are they used by any agent in the development phase? Should db-migration-plan.yaml live per-feature or build-level? Is cross-feature ordering explicitly defined anywhere?
```

## Alternative Approaches

### Approach 1: Fix Reference Docs Only (Minimal)

Align `instructions.md` and `AGENTS.md` with the agent definitions that already exist. Fix `db-migration-plan.yaml` path. Don't introduce `build-order.yaml`, don't change gates.

**Pros:**
- Smallest change — reference docs + path corrections only
- No new artifacts introduced
- No risk of breaking agent definitions
- Fast to implement and test

**Cons:**
- Cross-feature ordering gap remains unaddressed — agents will continue to improvise (like `task-order.md`)
- No automated enforcement via gates
- `db-migration-plan.yaml` path change across 12+ files is tedious but necessary
- Doesn't prevent future artifact drift

---

### Approach 2: Fix Docs + Move db-migration-plan + Introduce build-order.yaml + Update Gates (Recommended)

Full alignment: fix reference docs, move `db-migration-plan.yaml` to build-level, introduce `build-order.yaml` as canonical artifact, update gate checks.

**Pros:**
- Fixes ALL three identified problems (Tier 3 drift, db-migration scope, cross-feature ordering)
- Every artifact now has a defined producer, consumer, path, and format
- Gate checks enforce correctness automatically
- `build-order.yaml` closes the last gap in the SDD flow — the bootstrap now covers the full lifecycle from single-feature to multi-feature builds
- Consistent with the SDD philosophy: every workflow decision is artifact-driven, not improvised

**Cons:**
- Largest scope — touches 12+ files for db-migration path, introduces a new artifact type, updates gate skills
- `build-order.yaml` needs a schema designed and a template added to project-task-planner
- Orchestrator needs protocol updates for multi-feature mode
- New artifact means more documentation and more for users to learn
- Risk of over-engineering if most real projects only orchestrate one feature at a time

---

### Approach 3: Fix Docs + Move db-migration-plan + Fold Ordering Into Orchestrator (No New Artifact)

Instead of `build-order.yaml`, make the orchestrator compute cross-feature ordering on-the-fly by reading all features' `tasks.yaml` `depends_on` fields and topologically sorting.

**Pros:**
- No new artifact type — the orchestrator derives ordering from existing `tasks.yaml` data
- Cross-feature `depends_on` references already exist in the sample data (26+ cross-feature references found)
- Simpler folder structure — no `build-order.yaml` to maintain
- More "agentic" — orchestrator reasons about dependencies rather than consuming a static file

**Cons:**
- Orchestrator becomes significantly more complex — must parse all features' `tasks.yaml`, build a dependency graph, and topologically sort
- If cross-feature `depends_on` references are incomplete or wrong, the orchestrator has no way to detect it (a static `build-order.yaml` reviewed by a human would catch these)
- Debugging ordering issues is harder — no single file shows the computed order
- Violates the SDD principle that workflow decisions should be artifact-driven, not computed on-the-fly
- The project-task-planner currently writes `tasks.yaml` for ONE feature — it would need to validate cross-feature `depends_on` references, which requires reading other features' tasks

---

### Approach 4: Radical Simplification — Fold Tier 3 Into Specs + Keep Build-Level Only

Remove per-feature Tier 3 files entirely. Security/compliance/UX become sections in `specs.md`. Keep only build-level artifacts (`db-migration-plan.yaml`, `build-order.yaml`).

**Pros:**
- Eliminates per-feature artifact sprawl completely
- One source of truth per feature (`specs.md`)
- Fewer files for agents to read/write
- Build-level artifacts handle the cross-cutting concerns

**Cons:**
- Makes `specs.md` much larger and harder to maintain
- Loses separation of concerns — multiple agents write to same file, risking conflicts
- Breaks Tier 3 parallel execution (agents can't write to same file simultaneously)
- UX flows don't naturally fit in API-spec-style documents
- Major rework of 4+ agent definitions

## Validation Checklist
- [ ] `instructions.md` Agent I/O table uses canonical file paths for all Tier 3 agents
- [ ] `instructions.md` Folder Structure includes ui.md, security.md, compliance.md as conditional per-feature outputs
- [ ] `instructions.md` Folder Structure shows db-migration-plan.yaml at build-version level (not per-feature)
- [ ] `AGENTS.md` Folder Structure matches instructions.md
- [ ] `db-migration-plan.yaml` path updated in all 12+ files (see list in Change #2)
- [ ] `database-administrator.md` updated to read all features' specs.md
- [ ] `build-order.yaml` added as canonical artifact (if Approach 2)
- [ ] `project-task-planner.md` updated to produce `build-order.yaml` after all features' tasks.yaml (if Approach 2)
- [ ] `workflow-orchestrator.md` updated with multi-feature protocol (if Approach 2)
- [ ] gate/check.md validates Tier 3 outputs + build-level artifacts
- [ ] gate/report.md aggregates all sections
- [ ] No references to orphaned filenames (task-order.md, ux-flows.md, component-architecture.md, compliance-requirements.md, security-patterns.md) in any bootstrap file
- [ ] Planning phase re-run produces only canonical files

## Edge Cases
- Feature needs security review but NOT compliance — gate checks must distinguish required vs optional Tier 3 outputs based on auto-detection keywords in swarm-config.md
- First feature in a new build — `.ops/` baselines may not exist yet; agents need a "create baseline if missing" protocol
- Cross-cutting security/compliance requirements vs per-feature deltas — baseline/delta split must be explicit in agent definitions to avoid regenerating shared content
- Features with no UI — ui-designer should be skipped entirely (per swarm-config.md auto-detection), not produce an empty ui.md
- Parallel writes to `specs.md` — both security-engineer and compliance-engineer update specs.md with acceptance checks; if both run in parallel (Tier 3), they could conflict
- Single-feature builds — `build-order.yaml` may be unnecessary; orchestrator should skip it when only one feature exists
- Incremental v1+ builds — `db-migration-plan.yaml` may need to handle ALTER/migrate operations on existing tables, not just greenfield CREATE. Per-feature may work for isolated additions in v1+, but FK dependencies still need build-level visibility
- Circular cross-feature dependencies — topological sort in `build-order.yaml` must detect and reject cycles; project-task-planner should flag these
